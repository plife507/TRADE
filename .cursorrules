# TRADE Bot - Cursor Project Rules

Safety-first Bybit futures trading bot. See PROJECT_RULES.md for comprehensive rules.

## CRITICAL RULES - NEVER VIOLATE

### GLOBAL RULES (Entire Repository)

**Build-Forward Only**
- MUST NOT preserve backward compatibility unless explicitly stated.
- MUST remove legacy shims rather than maintain parallel paths.
- MUST delete obsolete code paths (e.g., `build_exchange_state_from_dict()`, `Candle` alias).

**TODO-Driven Execution (MANDATORY)**
- MUST NOT write code before TODO markdown exists in `docs/todos/`.
- Every code change MUST map to a TODO checkbox.
- If new work is discovered mid-implementation: STOP → update TODOs → continue.
- Work is NOT complete until TODOs are checked.

**Phase Discipline**
- Completed phases are FROZEN. MUST NOT rewrite earlier phases unless explicitly instructed.
- New requirements MUST be added as new phases or explicit mid-plan inserts.

**No Implicit Defaults (Fail Loud)**
- MUST NOT use implicit or silent defaults for required inputs.
- Missing declarations MUST raise errors, not infer behavior.
- Example: `FeedStore.from_dataframe()` with `indicator_columns=None` → empty dict, not default list.

**Closed-Candle Only + TradingView-Style MTF**
- All indicator computation MUST use closed candles only (never partial).
- HTF/MTF indicators MUST compute only on TF close.
- Between closes, last-closed values MUST forward-fill unchanged.
- MUST match TradingView `lookahead_off` semantics.

**Assumptions Must Be Declared**
- Any assumption MUST be stated before implementation.
- Architectural assumptions MUST be confirmed before proceeding.
- MUST NOT guess missing requirements—surface them explicitly.

**No Hardcoding**
- Symbols/pairs from config or user input, never in code
- Timeframes use TimeframeConfig, never string literals
- Indicator parameters as class attributes or config
- Risk parameters from config.risk.*
- File paths use Path objects or config paths
- API endpoints from config based on BYBIT_USE_DEMO

**Safety & API Discipline (LIVE Domain)**
- LIVE trades MUST go through `src/tools/*`—never call `bybit_client` directly.
- SIMULATOR trades use `SimulatedExchange.submit_order()` directly—MUST NOT depend on live tools.
- Risk manager checks MUST occur before every order (live or simulated).
- Demo mode MUST be tested before live.
- Reference docs (`reference/exchanges/`) MUST be checked before implementing exchange logic.

---

### DOMAIN RULES — SIMULATOR / BACKTEST (`src/backtest/`)

**Currency Model: USDT Only**
- Simulator account and margin currency is **USDT**.
- MUST NOT alias USD and USDT—they are semantically distinct.
- Canonical sizing field in simulator signals is `size_usdt`.
- MUST NOT use `size_usd` in simulator code—use `size_usdt`.

**Symbol Validation: USDT Pairs Only (Current Iteration)**
- Simulator MUST reject symbols not ending in "USDT" in the current iteration.
- `validate_usdt_pair()` MUST be called at config load, engine init, and before data fetch.
- Future iterations MAY support USDC perps or inverse contracts via config/version.

**Margin Mode: Isolated Only**
- Simulator supports only isolated margin mode.
- MUST reject `margin_mode="cross"` at config validation.

**Indicator Declaration: Explicit Only**
- Simulator MUST NOT compute indicators unless declared in FeatureSpec/Idea Card.
- Strategies MUST NOT assume any indicator exists by default.

**Snapshot Architecture**
- `RuntimeSnapshotView` is a read-only view—MUST NOT deep copy.
- Snapshot access MUST be O(1)—no DataFrame operations in hot loop.

---

### DOMAIN RULES — LIVE TRADING / EXCHANGE (`src/core/`, `src/exchanges/`)

**Currency Semantics: Exchange-Native**
- Live trading uses exchange-native currency semantics.
- `size_usd` in live trading represents **exchange-native notional**, not simulator accounting currency.
- Variable names may use `size_usd` per existing patterns.
- Simulator refactors MUST NOT force renames in live trading code.

**Domain Isolation**
- Simulator-only assumptions MUST NOT leak into live execution paths.
- Example: `src/core/risk_manager.py` uses `Signal.size_usd`—do NOT rename.

**Trading Execution Flow (MANDATORY)**
- ALL trades MUST flow through: Strategy → Risk Manager → Order Executor → Exchange
- NEVER call exchange methods directly from strategies
- NEVER bypass risk_manager for "quick" trades
- NEVER execute orders without Signal objects

**API Abstraction**
- Use ExchangeManager for all trading operations, never call pybit directly
- All API calls must go through rate_limiter.py
- Use batch endpoints when possible (10 orders = 1 API call)

---

### DOMAIN RULES — SHARED / CORE (`src/config/`, `src/utils/`, `src/data/`)

**Domain Agnosticism**
- Shared utilities MUST NOT embed simulator-only or live-only assumptions.
- If a rule differs by domain, enforcement MUST occur at the domain boundary.

**No Leaking Domain Logic**
- `src/utils/` MUST NOT contain trading logic.
- `src/config/` MUST NOT contain execution logic.
- `src/data/` provides data—MUST NOT enforce trading semantics.

---

### CURSOR-SPECIFIC RULES

**Markdown File Editing Efficiency (TOKEN CONSERVATION)**
- When editing markdown files, NEVER rewrite the entire file
- Use `search_replace` tool to make targeted edits to specific lines/sections
- Preserve all other content unchanged
- **IF a full rewrite is truly necessary**: ALWAYS prompt the user first

**Testing Through Real Interfaces (NO SYNTHETIC TESTS)**
- NEVER rely solely on synthetic unit tests
- After making changes, run the actual CLI (`python trade_cli.py`) to verify
- Test through the same paths a real user would use
- Always verify with real API calls (demo mode) when testing trading features

**Exchange API Reference (CRITICAL)**
- ALWAYS reference `reference/exchanges/` for API information
- Bybit API docs: `reference/exchanges/bybit/docs/v5/`
- pybit SDK: `reference/exchanges/pybit/`
- Never guess API parameters—always verify against reference docs

## Architecture Rules

### File Organization
- Keep files under 1500 lines - split into logical modules if larger
- DO NOT move existing files without explicit user permission
- Each module should have a single, clear responsibility

### Module Boundaries (Domain-Aware)

**SIMULATOR Domain (`src/backtest/`)**
- engine.py = Backtest orchestrator
- sim/ = Simulated exchange (pricing, execution, ledger, constraints)
- runtime/ = Snapshot, FeedStore, TFContext
- features/ = FeatureSpec, FeatureFrameBuilder

**LIVE Domain (`src/core/`, `src/exchanges/`)**
- core/ = Trading logic, risk management, order execution
- exchanges/ = Exchange-specific API wrappers (BybitClient)

**SHARED Domain**
- config/ = Configuration (domain-agnostic)
- data/ = Market data fetching, DuckDB storage
- tools/ = CLI/API surface (primary interface)
- utils/ = Logging, rate limiting, helpers
- strategies/ = Base classes and configs only (concrete strategies in research/)

### Strategy Location
- Concrete strategies live in research/strategies/{pending|final|archived}/, NOT src/strategies/
- src/strategies/ contains only: base_strategy.py, templates, and configs
- Use StrategyLoader to load strategies dynamically

## Configuration Pattern

Always use:
```python
from src.config.config import get_config
config = get_config()
config.risk.max_leverage      # Not hardcoded
config.bybit.use_demo         # Not hardcoded
config.trading.mode           # Not hardcoded
```

## Code Quality

### Type Hints
- Use type hints for all function parameters and returns
- Use dataclasses for structured data (Signal, MarketSnapshot, etc.)
- Use Enums for constants (TimeInForce, TriggerBy, etc.)

### Error Handling & Logging
- Minimal error handling - let errors surface for visibility
- Network/API errors should not crash the bot (graceful degradation)
- Use get_logger() from src.utils.logger
- Log all trading decisions with reasoning
- Log all risk rejections with details
- Never log API keys or secrets

### Dependencies
- Update requirements.txt when adding packages
- Pin versions for production dependencies
- Keep dependencies minimal - only what's needed

## Safety Rules

- All new trading features must work with Demo API first (BYBIT_USE_DEMO=true)
- Panic button must remain accessible in all modes
- Circuit breakers (daily loss, min balance) must be checked before every trade
- Never expose API keys in logs or output
- Demo API uses api-demo.bybit.com (fake money), Main API uses api.bybit.com (REAL money)

## Rate Limiting

Bybit V5 API limits:
- IP (all requests): 600/5sec, bot uses 100/sec (403 = 10min ban)
- Order create/amend/cancel: 10/sec/symbol, bot uses 8/sec
- Batch orders: 10/sec, max 10 orders/batch
- Position/Account GET: 50/sec, bot uses 40/sec

Best practices:
- Use batch endpoints when possible
- Cache instrument info in ExchangeManager._instruments
- Use WebSocket for real-time data instead of polling
- Monitor X-Bapi-Limit-Status headers, warn when < 5
- Exponential backoff on 10006 errors (rate limited)
- Separate API keys for data vs trading (different rate limit pools)

## Strategy Development

### Strategy Interface
- Must inherit from BaseStrategy
- Implement generate_signals() for single-TF or generate_signals_multi_tf() for MTF
- Return List[Signal] objects, never execute trades directly
- Use MarketSnapshot (legacy) or MultiTFSnapshot (MTF) for data
- All parameters must come from StrategyConfig, not hardcoded

### RBI Workflow
ideas.txt → AI Research → backtests/{date}/ → Testing → strategies/pending/ → Validation → strategies/final/ → Live Trading

## Multi-Timeframe (MTF) Rules

See **Critical Rules → Closed-Candle Only + TradingView-Style MTF** for core principles.

**LIVE Domain (Legacy)**
- Use TimeframeConfig for timeframe management
- Use MultiTFSnapshot for MTF data (not MarketSnapshot)
- Implement generate_signals_multi_tf() for MTF strategies

**SIMULATOR Domain**
- Use RuntimeSnapshotView with TFContext for HTF/MTF access
- HTF/MTF indicators computed only on TF close (no partial candles)
- Between closes, last-closed values forward-fill unchanged
- Access via snapshot: `snapshot.htf_ema_fast`, `snapshot.mtf_rsi`

**Shared Principles**
- HTF = trend/bias, MTF = structure, LTF/Exec = entry timing
- Always normalize timeframes using normalize_timeframe()
- Store in API format ("240" for 4H, "D" for daily)

## Data Management

**LIVE Domain**
- MarketData for live data (with caching)
- Caching: Prices 1-5s, OHLCV 1min, Funding 5min
- Instrument info cached in ExchangeManager

**SIMULATOR Domain**
- HistoricalDataStore for DuckDB operations (source of truth)
- FeedStore for precomputed numpy arrays (O(1) access)
- NO live API calls during backtest—all data from DuckDB

**SHARED**
- Historical data → data/market_data.duckdb
- Logs → logs/ with date-based naming
- NO synthetic/fake data - fail fast if real data unavailable

## CLI Rules

- All menus use numbered options
- Exit commands: q, quit, exit, x, back, b work at any prompt
- Color-coded output for status/warnings/errors
- Panic button always available (option 8 in main menu)
- Use termcolor for colored output

## Quick Reference Checklist

**Before Starting Work:**
- [ ] TODO markdown exists in `docs/todos/` for this work
- [ ] Assumptions documented and confirmed

**When Adding Features:**
- [ ] Correct domain identified (SIMULATOR, LIVE, or SHARED)
- [ ] No hardcoded values (symbols, timeframes, sizes, paths)
- [ ] Uses config system for all settings
- [ ] File under 1500 lines (split if needed)
- [ ] Type hints on all functions
- [ ] Updated requirements.txt if needed

**SIMULATOR Domain:**
- [ ] Uses `size_usdt` (not `size_usd`)
- [ ] Symbol ends in "USDT"
- [ ] Indicators explicitly declared in FeatureSpec
- [ ] Closed-candle only (no partial candles)
- [ ] O(1) snapshot access (no DataFrame in hot loop)

**LIVE Domain:**
- [ ] Trades flow through: Strategy → Risk → Executor → Exchange
- [ ] Works in demo mode first
- [ ] Respects rate limits
- [ ] Uses ExchangeManager, not direct pybit calls
- [ ] Logs all decisions

**After Completing Work:**
- [ ] TODO checkboxes marked complete
- [ ] Tests pass (unit tests + real interface testing)

## Project Philosophy

1. Safety first - Demo mode default, hard caps on leverage/position
2. Rate limit aware - Every API call goes through rate limiter
3. Agent-ready - Modular design for multi-agent swarm integration
4. Real data only - No synthetic data, fail fast on errors
5. Demo API first - All new trading logic tested on Bybit Demo API (api-demo.bybit.com) before main API
6. No real funds early - real mode only after passing demo + paper phases
7. Risk before profit - All orders go through risk_manager; no direct raw calls
8. Extensive logging - Every order, position change, risk rejection, panic activation logged
9. Graceful error handling - Network/API errors handled without crashes
10. Small real size - Hard caps on per-trade and daily risk in real mode

### API Modes

- Demo API (BYBIT_USE_DEMO=true): Uses api-demo.bybit.com with $1,000 fake money
- Main API (BYBIT_USE_DEMO=false): Uses api.bybit.com with REAL money
- Trading Modes: paper (simulated) or real (executes orders)

## Reference Files

**Project Documentation**
- CLAUDE.md - Detailed guidance for AI assistants (domain-aware rules)
- docs/project/PROJECT_RULES.md - Comprehensive development rules
- docs/project/PROJECT_OVERVIEW.md - Roadmap and current objectives

**TODO Phase Documents (Canonical Work Tracking)**
- docs/todos/SNAPSHOT_HISTORY_MTF_ALIGNMENT_PHASES.md - Snapshot, MTF, FeatureSpec
- docs/todos/SIMULATED_EXCHANGE_MODE_LOCKS_PHASES.md - USDT-only, isolated margin

**Architecture Documentation**
- docs/architecture/DATA_ARCHITECTURE.md - Data layer design
- docs/architecture/SIMULATED_EXCHANGE.md - Simulator design

**Exchange API Reference**
- reference/exchanges/bybit/docs/v5/ - Bybit V5 API docs
- reference/exchanges/pybit/ - pybit SDK reference

